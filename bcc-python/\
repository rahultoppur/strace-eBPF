#!/usr/bin/env python3

from bcc import BPF
import time
import argparse
import sys
import os

parser = argparse.ArgumentParser(
    description="A version of strace using eBPF")

parser.add_argument("-p", "--pid", help="trace this PID only", required=True)
args = parser.parse_args()

bpf_source = r"""
#include <linux/sched.h>

struct data_t {

    // Use PID_FILTER logic to set up appropriate types for each event

    u32 pid;
    int syscall_id;
    char comm[TASK_COMM_LEN];
    //unsigned long args[6];
    /*
    char args0[70];
    char args1[70];
    char args2[70];
    char args3[70];
    char args4[70];
    char args5[70];
    */
    char filename[16];
    /*
    int flags;
    unsigned short mode;
    */
    char argv[16];
};

BPF_PERF_OUTPUT(events);



TRACEPOINT_PROBE(raw_syscalls, sys_enter)
{

    // For each syscall in here, look up it's ID and correlate it. Then, depending on its
    // params, only print out it's related arguments.

    // Obtain pid and ppid. Only trace if pid is equal to the value 
    // we specify or if the ppid is also equal to the same value.


    u32 pid = bpf_get_current_pid_tgid() >> 32;
    struct task_struct *task;

    task = (struct task_struct *)bpf_get_current_task();
    u32 ppid = task->real_parent->tgid;

    PID_FILTER_BEGIN

    struct data_t data = {};

    data.pid = pid;
    data.syscall_id = args->id; 

    bpf_get_current_comm(&data.comm, sizeof(data.comm));


    /*
    if (args->id == 257) {
        bpf_probe_read(&data.filename, sizeof(data.filename), (const char *)args->args[1]);
        data.flags = args->args[2];
        data.mode = args->args[3];
    }
    */

    if (args->id == 59) {
        bpf_probe_read(&data.filename, sizeof(data.filename), (const char *)args->args[0]);
        bpf_probe_read(&data.argv, sizeof(data.filename), (const char *)args->args[1]);
    }

    /* 
    bpf_probe_read(&data.args0, sizeof(data.args0), (const char *)args->args[0]);
    bpf_probe_read(&data.args1, sizeof(data.args0), (const char *)args->args[1]);
    bpf_probe_read(&data.args2, sizeof(data.args0), (const char *)args->args[2]);
    bpf_probe_read(&data.args3, sizeof(data.args0), (const char *)args->args[3]);
    bpf_probe_read(&data.args4, sizeof(data.args0), (const char *)args->args[4]);
    bpf_probe_read(&data.args5, sizeof(data.args0), (const char *)args->args[5]);
    */

    events.perf_submit(args, &data, sizeof(data));

    PID_FILTER_END

    return 0;
}
"""

# Read PID from command line
if args.pid:
    bpf_source = bpf_source.replace("PID_FILTER_BEGIN", f"if (pid == {args.pid} || ppid == {args.pid}) {{")
    bpf_source = bpf_source.replace("PID_FILTER_END", f"}}")

b = BPF(text=bpf_source)

#print("%-10s %-4s %-10s %-20s %-20s %-20s %-20s %-20s %-20s" % ("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]", "ARGS[3]", "ARGS[4]", "ARGS[5]"))
print("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]", "ARGS[3]", "ARGS[4]", "ARGS[5]")
#print("%-10s %-4s %-10s %-15s %-15s %-15s" % ("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]"))

def print_event(cpu, data, size):
    event = b["events"].event(data)
    
    #print("%-10s %-4d %-10d %-20s %-20s %-20s %-20s %-20s %-20s" % (event.comm, event.pid, event.syscall_id, event.args0, event.args1, event.args2, event.args3, event.args4, event.args5))
    #print("%-10s %-4d %-10d %-20b %-20b %-20b %-20b %-20b %-20b" % (event.comm, event.pid, event.syscall_id, event.args0, event.args1, event.args2, event.args3, event.args4, event.args5))

    # incorporate hashmap here to map syscall IDs to actual names
    # another hashmap to link syscalls to which arguments they need (args0 - args5)

    #if event.syscall_id == 257: # replace this with hashmap
    #    print(f"OPENAT({event.filename} | {event.flags} | {event.mode})")

    if event.syscall_id == 59: # replace this with hashmap
        print(f"EXECVE({event.filename} | {event.argv0} | {event.argv1.decode('utf-8')})")

    #if event.syscall_id == 1:
    #    print(f"WRITE({event.args1}|{event.args2})")

    #if event.syscall_id == 9:
    #    print(f"MMAP({event.args0}, {event.args1}, {event.args2}, {event.args3}, {event.args4}) = {event.args5}")

    # If we see syscall ID 231 (exit_group), log the entry and stop tracing
    if event.syscall_id == 231 and event.comm == b"python3":
        print("exit_groups() received", "*" * 40)
        os._exit(0)

    #print("%-10s %-4d %-10d %-15x %-15x %-15x" % (event.comm, event.pid, event.syscall_id, event.args[0], event.args[1], event.args[2]))

b["events"].open_perf_buffer(print_event)
while 1:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        break

