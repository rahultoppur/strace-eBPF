#!/usr/bin/env python3

from bcc import BPF
from bcc.syscall import syscalls, syscall_name
import time
import argparse
import sys
import os
from ctypes import *
import socket, struct

parser = argparse.ArgumentParser(
    description="A version of strace using eBPF")

parser.add_argument("-p", "--pid", help="trace this PID only", required=True)
args = parser.parse_args()

bpf_source = r"""
#include <linux/sched.h>
//#include <net/sock.h>
#include <linux/socket.h>
#include <linux/types.h>
#include <linux/in.h>

struct data_t {

    // Stack space is shared, so account for all types of possibilities. Mostly just a combo of ints and char[N].

    u32 pid;
    int syscall_id;
    
    //TODO: Make sure to write syscall_id to events. That way, can translate it to syscall name later.
    // Use bcc built-in syscall converter file to do that. Other syscall implementation inside tracepoint
    // just do manually for now. Formatting in print of perf_buffer can be done using hashmap. But, you 
    // still need to determine what arguments need to go there.
    // For data_t, store string representations and int representations. Don't know which ones you'll end up
    // needing for certain syscalls. For now, do like the first 20? Use case statement.

    char comm[TASK_COMM_LEN];
    //unsigned long args[6];
    /*
    char args0[70];
    char args1[70];
    char args2[70];
    char args3[70];
    char args4[70];
    char args5[70];
    */
    char filename[16];

    int flags;
    unsigned short mode;
   
    //char argv1[20];
    char argv1[14];
    char argv2[20];
    char argv3[20];

    // IP address (for connect)
    u32 s_addr;
    u16 port;

};


BPF_PERF_OUTPUT(events);

TRACEPOINT_PROBE(raw_syscalls, sys_enter)
{

    // For each syscall in here, look up it's ID and correlate it. Then, depending on its
    // params, only print out it's related arguments.

    // Obtain pid and ppid. Only trace if pid is equal to the value 
    // we specify or if the ppid is also equal to the same value.


    u32 pid = bpf_get_current_pid_tgid() >> 32;
    struct task_struct *task;

    task = (struct task_struct *)bpf_get_current_task();
    u32 ppid = task->real_parent->tgid;

    PID_FILTER_BEGIN

    struct data_t data = {};

    data.pid = pid;
    data.syscall_id = args->id; 

    bpf_get_current_comm(&data.comm, sizeof(data.comm));

    char * first_arg;
    char *second_arg;
    char *third_arg;

    
    if (args->id == 257) {

        bpf_probe_read(&data.filename, sizeof(data.filename), (const char *)args->args[1]);
        data.flags = args->args[2];
        data.mode = args->args[3];
        
    }
    

    if (args->id == 42) {
    
        /*
        struct sockaddr_t {
            int family;
            char address[14];
        };
        */

        // For example for connect, we are using the built-in types within linux/socket.h

        //struct sockaddr_t sock = {};
        //struct sockaddr sock = {};
        //bpf_probe_read(&data.addr_len, sizeof(data.addr_len), args->args[2])
   

        //data.s_addr = in_addr;

        struct sockaddr* sock;
        bpf_probe_read(&sock, sizeof(sock), args->args[1]);

        struct sockaddr_in* addr_in = (struct sockaddr_in*)&sock;
        data.s_addr = addr_in->sin_addr.s_addr; // this is a primitive, so it's fine to do.
        data.port = addr_in->sin_port;


        //bpf_probe_read(&data.s_addr, sizeof(data.s_addr), &addr_in->sin_addr.s_addr);

        /*

        struct in_addr* in; 
        bpf_probe_read(&in, sizeof(in), &addr_in->sin_addr);

        bpf_probe_read(&data.s_addr, sizeof(u32), &in->s_addr);
        */

        //data.s_addr = in->s_addr;

        //bpf_probe_read(&sock, sizeof(sock), args->args[1]);
    
        //bpf_probe_read(&data.argv1, sizeof(sock.sa_data), sock.sa_data);
        //bpf_probe_read(&data.argv1, sizeof(data.argv1), args->args[1]);
    }

    if (args->id == 59) {

        // This works for execve (getting the args from there)
        char* my_args[10];

        // Think it's enough to just print the first arg of the exec...

        //const char** args1 = args->args[1];

        bpf_probe_read(&my_args, sizeof(my_args), args->args[1]);
        bpf_probe_read(&second_arg, sizeof(second_arg), (void *)args->args[2]);
        bpf_probe_read(&third_arg, sizeof(third_arg), (void *)args->args[3]);

        bpf_probe_read_str(&data.argv1, sizeof(data.argv1), my_args[1]);
        bpf_probe_read_str(&data.argv2, sizeof(data.argv2), second_arg);
        bpf_probe_read_str(&data.argv3, sizeof(data.argv2), third_arg);

        bpf_probe_read(&data.filename, sizeof(data.filename), (const char *)args->args[0]);
        //bpf_probe_read(&data.argv, sizeof(data.filename), args->args[1]);
    }

    /* 
    bpf_probe_read(&data.args0, sizeof(data.args0), (const char *)args->args[0]);
    bpf_probe_read(&data.args1, sizeof(data.args0), (const char *)args->args[1]);
    bpf_probe_read(&data.args2, sizeof(data.args0), (const char *)args->args[2]);
    bpf_probe_read(&data.args3, sizeof(data.args0), (const char *)args->args[3]);
    bpf_probe_read(&data.args4, sizeof(data.args0), (const char *)args->args[4]);
    bpf_probe_read(&data.args5, sizeof(data.args0), (const char *)args->args[5]);
    */

    events.perf_submit(args, &data, sizeof(data));

    PID_FILTER_END

    return 0;
}

/*
int handle_openat( *ctx) {
   
    bpf_probe_read(&data.filename, sizeof(data.filename), (const char *)args->args[1]);
    data.flags = args->args[2];
    data.mode = args->args[3];

    syscalls.call(ctx, 257);

    return 0;
}
*/


"""

# Read PID from command line
if args.pid:
    bpf_source = bpf_source.replace("PID_FILTER_BEGIN", f"if (pid == {args.pid} || ppid == {args.pid}) {{")
    bpf_source = bpf_source.replace("PID_FILTER_END", f"}}")

b = BPF(text=bpf_source)

#syscalls = b["sycalls"]

#handle_openat_fn = b.load_func("handle_openat", BPF.TRACEPOINT)

#syscalls = b.get_table("syscalls")
#syscalls[c_int(257)] = c_int(handle_openat_fn.fd)


#print("%-10s %-4s %-10s %-20s %-20s %-20s %-20s %-20s %-20s" % ("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]", "ARGS[3]", "ARGS[4]", "ARGS[5]"))
print("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]", "ARGS[3]", "ARGS[4]", "ARGS[5]")
#print("%-10s %-4s %-10s %-15s %-15s %-15s" % ("COMM", "PID", "SYSCALL_ID", "ARGS[0]", "ARGS[1]", "ARGS[2]"))

def print_event(cpu, data, size):
    event = b["events"].event(data)
    
    #print("%-10s %-4d %-10d %-20s %-20s %-20s %-20s %-20s %-20s" % (event.comm, event.pid, event.syscall_id, event.args0, event.args1, event.args2, event.args3, event.args4, event.args5))
    #print("%-10s %-4d %-10d %-20b %-20b %-20b %-20b %-20b %-20b" % (event.comm, event.pid, event.syscall_id, event.args0, event.args1, event.args2, event.args3, event.args4, event.args5))

    # incorporate hashmap here to map syscall IDs to actual names
    # another hashmap to link syscalls to which arguments they need (args0 - args5)

    #print(syscall_name(event.syscall_id).decode('utf-8')) # Print associated name with each syscall
   
    
    # Each formatted-specific print goes here. Can control output as well, as well as formatting, parens, etc.

    #print_format = { 257 : f"({ event.filename} | {event.flags} | {event.mode})" }

    #sys_name, syscall_args = syscall_name(event.syscall_id), print_format.get(event.syscall_id)

    #print(f"{sys_name}{syscall_args}")


    #print(f"{syscall_name(event.syscall_id).decode('utf-8')}{print_format[event.syscall_id]}")

    #if event.syscall_id == 257: # replace this with hashmap
        #print(f"OPENAT({event.filename} | {event.flags} | {event.mode})") # put each format string in another map, call it from a python module (place in another file)
        # eventually also put C program in another file (bpf source).

        #print_format = { 257 : f"({ event.filename} | {event.flags} | {event.mode})" }

        #sys_name, syscall_args = syscall_name(event.syscall_id), print_format[event.syscall_id]

        #print(f"{sys_name}{syscall_args}")
    
    if event.syscall_id == 59: # replace this with hashmap
    #    #print(f"EXECVE(%s %s %s %s %s %s)" % (event.filename, event.argv1[0], event.argv1[1], event.argv1[2], event.argv2, event.argv3))
        print(f"EXECVE(%s %s %s %s)" % (event.filename, event.argv1, event.argv2, event.argv3))
    #    #print("%-10s %-10s" % (event.filename, event.argv))
    
    if event.syscall_id == 42:
        print(f"CONNECT({socket.inet_ntoa(struct.pack('<L', event.s_addr))} : {event.port})")
        #print(f"CONNECT(%s)" % socket.inet_ntoa(struct.pack('!L', event.s_addr)))

    #if event.syscall_id == 1:
    #    print(f"WRITE({event.args1}|{event.args2})")

    #if event.syscall_id == 9:
    #    print(f"MMAP({event.args0}, {event.args1}, {event.args2}, {event.args3}, {event.args4}) = {event.args5}")

    # If we see syscall ID 231 (exit_group), log the entry and stop tracing
    if event.syscall_id == 231 and event.comm == b"python3":
        print("exit_groups() received", "*" * 40)
        os._exit(0)

    #print("%-10s %-4d %-10d %-15x %-15x %-15x" % (event.comm, event.pid, event.syscall_id, event.args[0], event.args[1], event.args[2]))

b["events"].open_perf_buffer(print_event)
while 1:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        break

